<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      font-family: 'Arial', sans-serif;
      color: #fff;
      overflow: auto;
      padding: 10px;
      box-sizing: border-box;
    }

    h1 {
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      margin: 10px 0;
    }

    #gameContainer {
      position: relative;
      background: #111;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      width: 100%;
      max-width: 600px;
      padding: 0;
    }

    #gameCanvas {
      background: #222;
      border: 2px solid #444;
      border-radius: 5px;
      width: 100%;
      height: auto;
      aspect-ratio: 1 / 1;
      display: block;
      max-width: 100%;
    }

    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 5px;
    }

    #gameOverScreen h2 {
      font-size: 2em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #gameOverScreen button {
      padding: 10px 20px;
      font-size: 1.2em;
      background: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #gameOverScreen button:hover {
      background: #c0392b;
    }

    #info {
      margin-top: 20px;
      font-size: 1em;
      text-align: center;
      opacity: 0.8;
      width: 100%;
      max-width: 600px;
    }

    #score {
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      margin-bottom: 10px;
    }

    #instructions {
      font-size: 1em;
      margin-bottom: 10px;
    }

    #pauseButton {
      padding: 8px 16px;
      font-size: 1em;
      background: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #pauseButton:hover {
      background: #c0392b;
    }

    #welcomePopup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.5s ease-out;
    }

    #welcomePopup .popup-content {
      background: linear-gradient(135deg, #2a5298, #1e3c72);
      border-radius: 15px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      text-align: center;
      transform: translateY(-50px);
      animation: slideIn 0.5s ease-out forwards;
    }

    #welcomePopup h2 {
      font-size: 1.8em;
      margin-bottom: 20px;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    #welcomePopup button {
      padding: 12px 30px;
      font-size: 1.2em;
      background: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
      animation: pulse 2s infinite;
    }

    #welcomePopup button:hover {
      background: #c0392b;
      box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
      transform: scale(1.05);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideIn {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
      50% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.8); }
      100% { box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      body {
        padding: 10px;
        justify-content: flex-start;
        min-height: 100vh;
      }

      h1 {
        font-size: 2em;
        margin: 5px 0;
      }

      #gameContainer {
        max-width: 100%;
        width: 100%; /* Use full width */
        margin: 0 auto;
        padding: 0;
      }

      #gameCanvas {
        width: 100%;
        max-width: none;
        min-width: 350px; /* Increased minimum size for better visibility */
        margin: 0 auto;
      }

      #gameOverScreen h2 {
        font-size: 1.5em;
      }

      #gameOverScreen button {
        padding: 8px 16px;
        font-size: 1em;
      }

      #info {
        margin-top: 10px;
        width: 100%;
      }

      #score {
        font-size: 1em;
      }

      #instructions {
        font-size: 0.9em;
      }

      #pauseButton {
        padding: 6px 12px;
        font-size: 0.9em;
      }

      #welcomePopup .popup-content {
        padding: 20px;
        max-width: 300px;
      }

      #welcomePopup h2 {
        font-size: 1.5em;
      }

      #welcomePopup button {
        padding: 10px 20px;
        font-size: 1em;
      }
    }

    /* Further adjustment for very small screens */
    @media (max-width: 400px) {
      #gameCanvas {
        min-width: 100%; /* Ensure it takes full width on very small screens */
      }
    }
  </style>
</head>
<body>
  <h1>Snake Game</h1>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="gameOverScreen">
      <h2>Game Over!</h2>
      <button onclick="restartGame()">Restart</button>
    </div>
  </div>
  <div id="info">
    <div id="score">Score: 0</div>
    <div id="instructions">Use arrow keys or swipe to move the snake. Eat the red orbs to grow! Press P or tap Pause to pause/resume.</div>
    <button id="pauseButton" onclick="togglePause()">Pause</button>
  </div>
  <div id="welcomePopup">
    <div class="popup-content">
      <h2>Enjoy the Snake Game!<br>Created by Ashraf Shaik</h2>
      <button onclick="closePopup()">Start Playing</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const pauseButton = document.getElementById('pauseButton');
    const welcomePopup = document.getElementById('welcomePopup');

    let gridSize = 20; // Will be recalculated dynamically
    let tileCount = 20; // Will be recalculated dynamically
    let snake = [
      { x: 10, y: 10 }
    ];
    let food = { x: 15, y: 15 };
    let dx = 0;
    let dy = 0;
    let score = 0;
    let gameSpeed = 200; // Initial slow speed (ms per frame)
    const minSpeed = 50; // Minimum speed (fastest)
    const maxSpeed = 10; // Maximum speed (fastest practical limit)
    const speedIncrement = 2; // Smaller increment for gradual increase
    let gameLoop;
    let isPaused = true; // Start paused until pop-up is closed

    // Trigger confetti when popup appears
    document.addEventListener('DOMContentLoaded', () => {
      confetti({
        particleCount: 150,
        spread: 80,
        origin: { y: 0.5 },
        colors: ['#e74c3c', '#2ecc71', '#3498db', '#f1c40f'],
        zIndex: 1001 // Ensure confetti appears above popup
      });
    });

    // Load snake skin image
    const snakeSkin = new Image();
    snakeSkin.src = 'snake-skin.png'; // Replace with your image path or URL
    snakeSkin.onload = () => {
      // Wait for pop-up to close before starting game
    };
    snakeSkin.onerror = () => {
      console.error('Failed to load snake skin image. Using fallback color.');
    };

    function closePopup() {
      const popup = document.getElementById('welcomePopup');
      popup.style.animation = 'fadeOut 0.5s ease-in';
      setTimeout(() => {
        popup.style.display = 'none';
        isPaused = false;
        gameLoop = setInterval(drawGame, gameSpeed);
      }, 500); // Match animation duration
    }

    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const availableWidth = window.innerWidth - 20; // Account for padding
      const availableHeight = window.innerHeight - 100; // Reduced margin for more space
      let maxWidth;

      // Scale canvas size inversely with screen size on mobile
      if (window.innerWidth <= 600) {
        // On smaller screens, use a larger percentage of the available space
        maxWidth = Math.min(availableWidth, availableHeight) * 0.95; // Use 95% of the smaller dimension
      } else {
        // On larger screens, cap at a reasonable size
        maxWidth = Math.min(availableWidth, availableHeight, 600) * 0.9;
      }

      // Set the container and canvas size
      container.style.width = `${maxWidth}px`;
      container.style.height = `${maxWidth}px`;
      
      // Set the CSS size
      canvas.style.width = `${maxWidth}px`;
      canvas.style.height = `${maxWidth}px`;
      
      // Set the internal drawing resolution to match CSS size
      canvas.width = maxWidth;
      canvas.height = maxWidth;
      
      // Recalculate gridSize and tileCount
      tileCount = 20; // Fixed number of tiles
      gridSize = maxWidth / tileCount; // Adjust gridSize to fit canvas
      
      // Adjust snake and food positions to stay within new grid
      snake = snake.map(segment => ({
        x: Math.min(segment.x, tileCount - 1),
        y: Math.min(segment.y, tileCount - 1)
      }));
      food.x = Math.min(food.x, tileCount - 1);
      food.y = Math.min(food.y, tileCount - 1);
    }

    function drawGame() {
      // Clear canvas
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      for (let i = 0; i < tileCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }

      // If paused, show pause message and skip game logic
      if (isPaused) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = `${gridSize * 1.5}px Arial`; // Scale font size with grid
        ctx.textAlign = 'center';
        ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
        return;
      }

      // Move snake with wrap-around
      let head = { x: snake[0].x + dx, y: snake[0].y + dy };
      // Wrap around edges
      if (head.x < 0) head.x = tileCount - 1;
      if (head.x >= tileCount) head.x = 0;
      if (head.y < 0) head.y = tileCount - 1;
      if (head.y >= tileCount) head.y = 0;
      snake.unshift(head);

      // Check if snake ate food
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreDisplay.textContent = `Score: ${score}`;
        generateFood();
        // Gradually increase speed
        if (gameSpeed > maxSpeed) {
          gameSpeed = Math.max(maxSpeed, gameSpeed - speedIncrement);
          clearInterval(gameLoop);
          gameLoop = setInterval(drawGame, gameSpeed);
        }
      } else {
        snake.pop();
      }

      // Check self-collision
      if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      // Draw snake with snake skin image
      snake.forEach(segment => {
        if (snakeSkin.complete && snakeSkin.naturalWidth !== 0) {
          ctx.drawImage(snakeSkin, segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4);
        } else {
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          gradient.addColorStop(0, '#27ae60');
          gradient.addColorStop(1, '#2ecc71');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.roundRect(segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4, 5);
          ctx.fill();
        }
      });

      // Draw food as glowing orb
      ctx.beginPath();
      ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 2, 0, Math.PI * 2);
      ctx.fillStyle = '#e74c3c';
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#e74c3c';
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function generateFood() {
      food.x = Math.floor(Math.random() * tileCount);
      food.y = Math.floor(Math.random() * tileCount);
      if (snake.some(segment => segment.x === food.x && segment.y === food.y)) {
        generateFood();
      }
    }

    function endGame() {
      clearInterval(gameLoop);
      gameOverScreen.style.display = 'flex';
    }

    function togglePause() {
      if (gameOverScreen.style.display === 'flex' || welcomePopup.style.display === 'flex') return; // Don't pause during game over or pop-up
      isPaused = !isPaused;
      if (isPaused) {
        clearInterval(gameLoop);
        pauseButton.textContent = 'Resume';
      } else {
        gameLoop = setInterval(drawGame, gameSpeed);
        pauseButton.textContent = 'Pause';
      }
    }

    function restartGame() {
      snake = [{ x: 10, y: 10 }];
      food = { x: 15, y: 15 };
      dx = 0;
      dy = 0;
      score = 0;
      gameSpeed = 200; // Reset to initial slow speed
      isPaused = false;
      scoreDisplay.textContent = `Score: ${score}`;
      gameOverScreen.style.display = 'none';
      pauseButton.textContent = 'Pause';
      clearInterval(gameLoop);
      gameLoop = setInterval(drawGame, gameSpeed);
    }

    // Keyboard controls
    document.addEventListener('keydown', e => {
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
      } else if (!isPaused && gameOverScreen.style.display !== 'flex' && welcomePopup.style.display !== 'flex') {
        switch (e.key) {
          case 'ArrowUp':
            if (dy === 0) { dx = 0; dy = -1; }
            break;
          case 'ArrowDown':
            if (dy === 0) { dx = 0; dy = 1; }
            break;
          case 'ArrowLeft':
            if (dx === 0) { dx = -1; dy = 0; }
            break;
          case 'ArrowRight':
            if (dx === 0) { dx = 1; dy = 0; }
            break;
        }
      }
    });

    // Touch controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isPaused && gameOverScreen.style.display !== 'flex' && welcomePopup.style.display !== 'flex') {
        const touch = e.touches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;

        // Determine swipe direction
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          if (deltaX > 30 && dx === 0) { // Swipe right
            dx = 1;
            dy = 0;
          } else if (deltaX < -30 && dx === 0) { // Swipe left
            dx = -1;
            dy = 0;
          }
        } else {
          // Vertical swipe
          if (deltaY > 30 && dy === 0) { // Swipe down
            dx = 0;
            dy = 1;
          } else if (deltaY < -30 && dy === 0) { // Swipe up
            dx = 0;
            dy = -1;
          }
        }

        // Update touch start position to prevent repeated swipes
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }
    });

    // Initialize canvas size and listen for resize events
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Initial resize
  </script>
</body>
</html>